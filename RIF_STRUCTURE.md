# RIF Directory Structure

This document maps the codebase to RIF layers without changing behavior.

## rif-core: Job Orchestration Engine

**Purpose:** Manage job lifecycle, enforce state ownership, maintain filesystem authority.

```
server/lib/
├── filesystem.ts          # State directories, metadata I/O, job folder structure
├── job-state.ts           # State enum, transition validation, actor enforcement
├── job-moves.ts           # Atomic directory moves (race-safe state transitions)
├── db-init.ts             # Database rebuild from filesystem on startup
└── ytdlp-classifier.ts    # Deterministic failure classification (reference)
```

**Key Exports:**

- `createJobFolder(url)` — Create new job in NEW state
- `readMetadata(jobId)` — Read job metadata from filesystem
- `writeMetadata(jobId, metadata)` — Write job metadata to filesystem
- `moveJob(jobId, from, to, actor)` — Atomic state transition
- `validateTransition(from, to, actor)` — Verify state ownership
- `classifyYtdlpFailure(stderr, stdout)` — Classify download failures

---

## rif-adapters: Pluggable Workers

**Purpose:** Process jobs, write artifacts, update metadata, transition states.

```
server/workers/
├── ytdlp-worker.ts        # Reference adapter: YouTube download + failure classification
├── demucs-worker.ts       # Feature adapter: Stem separation (no state transitions)
├── lyrics-worker.ts       # Feature adapter: Lyrics lookup (no state transitions)
└── audacity-worker.ts     # Feature adapter: Audacity session generation (no state transitions)
```

**Adapter Types:**

| Type | Example | State Transitions | Responsibility |
|------|---------|-------------------|-----------------|
| Lifecycle | ytdlp-worker | CLAIMED→RUNNING→DONE/FAILED | Drive job through pipeline |
| Feature | demucs-worker, lyrics-worker, audacity-worker | None | Add metadata/artifacts |
| Utility | (future) | System-owned | Reclaim, repair, inspect |

**Adding New Adapters:**

1. Create `server/workers/{name}-worker.ts`
2. Follow adapter template in RIF_ARCHITECTURE.md
3. Implement idempotent processing
4. Update metadata with results
5. Add tests in `server/workers/{name}-worker.test.ts`

---

## rif-api: HTTP/tRPC Surface

**Purpose:** Expose filesystem truth via HTTP, never infer state, never retry.

```
server/routers/
├── jobs.ts                # Job lifecycle endpoints (create, list, get, logs, artifacts)
└── (in server/routers.ts) # Main app router wiring

server/_core/
├── context.ts             # tRPC context (auth, request/response)
├── trpc.ts                # tRPC client/server setup
└── (other framework files)
```

**Endpoints:**

- `POST /api/jobs` — Create job from URL
- `GET /api/jobs` — List jobs with filtering/pagination
- `GET /api/jobs/:id` — Get job details
- `GET /api/jobs/:id/logs` — Stream job logs
- `GET /api/jobs/:id/artifacts` — List artifacts
- `GET /api/health` — Health check

**Design Principles:**

- Read filesystem truth directly
- Never infer state
- Never retry
- Surface refusal reasons verbatim
- No abstraction beyond necessity

---

## Database Schema

**Purpose:** Derived index for querying; rebuilt from filesystem on startup.

```
drizzle/
├── schema.ts              # Job table (mirrors filesystem state)
└── migrations/            # Auto-generated by drizzle-kit
```

**Job Table Fields:**

- id, jobId (UUID)
- state (NEW, CLAIMED, RUNNING, DONE, FAILED)
- metadata (JSON, full metadata.json)
- createdAt, updatedAt
- ownerId, leaseExpiresAt

**Invariant:** Database is never authoritative. On startup, `initializeDatabaseFromFilesystem()` rebuilds from truth.

---

## Filesystem Storage

**Purpose:** Authoritative job state and artifacts.

```
{STORAGE_ROOT}/jobs/
├── NEW/
│   └── {jobId}/
│       ├── metadata.json
│       └── logs/
├── CLAIMED/
│   └── {jobId}/
│       ├── metadata.json
│       └── logs/
├── RUNNING/
│   └── {jobId}/
│       ├── metadata.json
│       ├── download/
│       ├── separation/
│       ├── lyrics/
│       ├── audacity/
│       └── logs/
├── DONE/
│   └── {jobId}/
│       ├── metadata.json
│       ├── download/
│       │   ├── audio.m4a
│       │   └── manifest.json
│       ├── separation/
│       │   ├── stems/
│       │   │   ├── vocals.wav
│       │   │   ├── drums.wav
│       │   │   ├── bass.wav
│       │   │   └── other.wav
│       │   └── manifest.json
│       ├── lyrics/
│       │   ├── lyrics.txt
│       │   ├── source.json
│       │   └── manifest.json
│       ├── audacity/
│       │   ├── project.aup3
│       │   └── manifest.json
│       └── logs/
└── FAILED/
    └── {jobId}/
        ├── metadata.json
        └── logs/
```

**Invariants:**

- Job exists because folder exists
- State is directory name
- Metadata is authoritative
- Artifacts are immutable once written
- Logs are append-only

---

## Testing Structure

**Purpose:** Verify framework guarantees and adapter behavior.

```
server/lib/
├── filesystem.test.ts     # Filesystem module tests
├── job-state.test.ts      # State machine tests
├── job-moves.test.ts      # Atomic move tests
├── db-init.test.ts        # Database initialization tests
└── ytdlp-classifier.test.ts # Failure classification tests

server/workers/
├── ytdlp-worker.test.ts   # Download worker tests
├── demucs-worker.test.ts  # Demucs adapter tests
├── lyrics-worker.test.ts  # Lyrics adapter tests
└── audacity-worker.test.ts # Audacity adapter tests
```

**Test Principles:**

- Verify invariants (filesystem authority, state ownership, idempotency)
- Test success and failure paths
- Verify metadata updates
- Verify state transitions
- Test crash recovery (delete DB, restart, verify recovery)

---

## CLI Orchestration

**Purpose:** Thin wrapper for job submission and monitoring.

```
server/cli.ts             # CLI commands (from-url, list, status, logs, artifacts, download)
```

**Commands:**

- `ego from-url <url>` — Create job and monitor progress
- `ego list` — List all jobs
- `ego status <jobId>` — Get job status
- `ego logs <jobId>` — View job logs
- `ego artifacts <jobId>` — List job artifacts
- `ego download <jobId>` — Download results

**Design:** No new business logic; pure orchestration of existing modules.

---

## Migration Path: From E.G.O. to RIF

**Current State:** E.G.O. Studio Audio is a specific instance of RIF.

**To Reuse RIF for New Ingestion Pipelines:**

1. Copy `server/lib/` (rif-core) — Unchanged
2. Copy `server/lib/db-init.ts` — Unchanged
3. Create new adapters in `server/workers/` following template
4. Create new API endpoints in `server/routers/` following pattern
5. Update metadata schema in `drizzle/schema.ts` for new adapter fields
6. Add tests for new adapters

**Example:** Building a "podcast ingestion" pipeline

```
server/workers/
├── podcast-download-worker.ts  # Download podcast episodes
├── podcast-transcribe-worker.ts # Transcribe audio
└── podcast-metadata-worker.ts   # Extract metadata
```

All three adapters use the same rif-core; only the business logic changes.

---

## Guarantees Preserved

| Guarantee | How RIF Ensures It |
|-----------|-------------------|
| Filesystem Authority | State encoded in directory name, never inferred |
| State Ownership | Actor validation in moveJob(), enforced at compile time |
| Atomicity | fs.rename() on same filesystem, no partial states |
| Idempotency | Artifact detection + metadata check in each adapter |
| Restart-Safety | Database rebuild from filesystem on every startup |
| Observability | Structured logs + metadata for all transitions |
| Deterministic Failure | Failure classification, not generic errors |

---

## No Behavior Changes

This restructuring is **documentation and organization only**. No code was moved, no logic was changed, no tests were modified. The framework is identical to the previous implementation; only the mental model is clarified.

**Verification:** All existing tests pass without modification.
